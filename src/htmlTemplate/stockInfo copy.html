<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>個股資訊</title>
</head>
<body>
    <h1>個股資訊</h1>
    <div id="data"></div>
</body>

<script>
    let stock_id = '2330'
    const START_DATE = '2022-01-01'
    const url = `https://api.finmindtrade.com/api/v4/data?dataset=TaiwanStockPrice&data_id=${stock_id}&start_date=${START_DATE}`
    let stockData;
    // let date = '2025-10-10'//移動的日期
    // let weeks = []
    // let day = null //星期幾


    async function getData() {
      const resopen = await fetch(url)
      stockData = await resopen.json() 
      weeksData()//取得stockData資料在執行
    } 
    //週K數據
    async function weeksData() {
        let open; //該週的第一個交易日的開盤價。
        let close;//該週的最後一個交易日的收盤價
        let hight;//該週內所有日期的最高價
        let low;//該週內所有日期的最低價
        let volume;//該週內所有日期的成交量總和
        let date = [];//該月的最後一個交易日的日期。
        //星期一~星期五為一週
        //當日期為星期日為[0]，星期為六為[6]        
        const weeksWithData = stockData.data.reduce((acc,item) => {
            const day = new Date(item.date).getDay() 
            // 跨週判斷需要參考前一個 item 的 date
            const lastWeek = acc[acc.length - 1]
            const prevItem = lastWeek ? lastWeek[lastWeek.length - 1] : null
            const prevDay = prevItem ? new Date(prevItem.date).getDay() : -1
            //跨週邏輯
            //1.初始情況(acc是空的)，也解決了第一週不是星期一的問題。
            //2.星期1
            //3.避免產生[1,2,2,3,4]
            if(acc.length === 0 || day === 1 || day <= prevDay) {
                acc.push([])
            }
            acc[acc.length - 1].push(item)  
            return acc
            
        },[]) 
        // console.log(daysArray)
        
        //二維陣列
        //每週的第一個物件
        const firstDayOfWeek = weeksWithData.map(item => item[0])
        //每週的最後一個物件
        const lastDayOfWeek = weeksWithData.map(item => item[item.length - 1]) 
        open = firstDayOfWeek.map(item => item.open) 
        close = lastDayOfWeek.map(item => item.close)
       
        hight = weeksWithData.map(arrayItem => {
            const dailyMaxPrices = arrayItem.map(dayItem => dayItem.max)
            return Math.max(...dailyMaxPrices)
        })
        low = weeksWithData.map(arrayItem => {
            const dailyMinPrices = arrayItem.map(dayItem => dayItem.min)
            return Math.min(...dailyMinPrices)
        })
        volume = weeksWithData.map(arrayItem => {
             const dailyVolume = arrayItem.map(dayItem => dayItem.Trading_Volume)

             let aWeekTotalVolume = dailyVolume.reduce((acc,item) => {
                return acc + item
             },0)
            
            return aWeekTotalVolume 
        })

         
        //該月的最後一個交易日的日期 邏輯流程
        // const flatWeeksWithData = weeksWithData.flat()
 
        // function myCallback({date}) {
        //     const d = new Date(date)
        //     const year = d.getFullYear().toString()
        //     const month =( d.getMonth() + 1).toString()
        //     return `${year}-${month}`
        // }
        // const monthlyData = Object.groupBy(flatWeeksWithData,myCallback)
         
        // for(const[monthKey,dataArray] of Object.entries(monthlyData)) {
        //     const lastObject = dataArray[dataArray.length - 1]
        //     const lastDate = lastObject.date

        //     date.push(lastDate)       
        // }

        console.log(monthlyData)      
    }

    getData()
</script>
</html>
<!-- 
ˊ週K: 找出當週的第一個交易日 和 找出當週的最後一個交易日







-->